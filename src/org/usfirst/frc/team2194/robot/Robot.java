// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc.team2194.robot;

import org.usfirst.frc.team2194.robot.commands.AutonomousCommand;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossChevalDeFriseGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossDrawbridgeGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossLowBarGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossMoatGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossPortcullisGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossRampartsGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossRockWallGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossRoughTerrainGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.CrossSallyPortGroup;
import org.usfirst.frc.team2194.robot.commands.CrossDefences.DoNothingGroup;
import org.usfirst.frc.team2194.robot.commands.Gyro.ResetGyro;
import org.usfirst.frc.team2194.robot.commands.PIDSets.SetPIDFLinearPosition;
import org.usfirst.frc.team2194.robot.commands.PIDSets.SetPIDFMotors;
import org.usfirst.frc.team2194.robot.commands.PIDSets.SetPIDFMotorsGyro;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.DrivesSpeedSourceSelect;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.EngageLowGear;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.RobotOKCheck;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.RobotOrient;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.RobotPitchPosition;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.RobotPosition;
import org.usfirst.frc.team2194.robot.commands.RobotMotion.RobotVisionOrient;
//import org.usfirst.frc.team2194.robot.commands.Shooter.FlashlightOff;
import org.usfirst.frc.team2194.robot.commands.Shooter.PositionAngleShooter;
import org.usfirst.frc.team2194.robot.commands.Shooter.RetractBallSolenoid;
import org.usfirst.frc.team2194.robot.commands.Shooter.RunLeftShooter;
import org.usfirst.frc.team2194.robot.commands.Shooter.RunRightShooter;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.DoNothingSlotGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove1LeftGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove2CenterGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove2LeftGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove3CenterGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove4CenterGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove5CenterGroup;
import org.usfirst.frc.team2194.robot.commands.SlotMoves.SlotMove5RightGroup;
import org.usfirst.frc.team2194.robot.subsystems.AirCompressor;
import org.usfirst.frc.team2194.robot.subsystems.AngleShooterMotor;
import org.usfirst.frc.team2194.robot.subsystems.GyroRotate;
import org.usfirst.frc.team2194.robot.subsystems.LeftPositionLinear;
import org.usfirst.frc.team2194.robot.subsystems.LeftShooterMotor;
import org.usfirst.frc.team2194.robot.subsystems.LeftSideDrive;
import org.usfirst.frc.team2194.robot.subsystems.Lidar;
import org.usfirst.frc.team2194.robot.subsystems.Manipulators;
import org.usfirst.frc.team2194.robot.subsystems.PitchPosition;
import org.usfirst.frc.team2194.robot.subsystems.PowerPanel;
import org.usfirst.frc.team2194.robot.subsystems.RightPositionLinear;
import org.usfirst.frc.team2194.robot.subsystems.RightShooterMotor;
import org.usfirst.frc.team2194.robot.subsystems.RightSideDrive;
import org.usfirst.frc.team2194.robot.subsystems.VisionRotate;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {

	public static double[] speedAngleArray;

	public static boolean debugLeftSpeedPID;
	public static boolean debugRightSpeedPID;
	public static boolean debugAngleShooterMotor;
	public static boolean debugRightShooterMotor;
	public static boolean debugLeftShooterMotor;
	public static boolean debugLeftLinear;
	public static boolean debugRightLinear;
	public static boolean debugPitchPosition;

	public static boolean shootOverRobotVision;// Ethan

	public static boolean debugGyroRotate;

	public static boolean inAutonomous;

	public final static double kCollisionThreshold_DeltaG = 1.5f;

	public static Command autonomousCommand;
	public static Command choicesSelect;
	public static SendableChooser defenseType;
	public static SendableChooser defenseSlot;
	public static SendableChooser goalTarget;

	NetworkTable table; // used for vision communication
	public static double xCameraVal = 0;
	public static double yCameraVal = 0;

	public static int defenseSelected;
	public static int defenseSlotSelected;
	public static int goalTargetSelected;

	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static LeftSideDrive leftSideDrive;
	public static RightSideDrive rightSideDrive;
	public static GyroRotate gyroRotate;
	public static LeftPositionLinear leftPositionLinear;
	public static RightPositionLinear rightPositionLinear;
	public static RightShooterMotor rightShooterMotor;
	public static LeftShooterMotor leftShooterMotor;
	public static Manipulators manipulators;
	public static PitchPosition pitchPosition;
	public static VisionRotate visionRotate;
	public static double shooterMotorMaxRPM = 6000;
	public static double encoderCountsPerRevShooterMotor = 4096;

	public static AngleShooterMotor angleShooterMotor;
	// public static double angleShooterMotorMaxRPM = 6000;

	public static double encoderCountsPerRevAngleshooterMotor = 4096;
	public static double angleEncoderRevtoShooterGearRatio = 6;
	public static double shooterAngleHomePosition = 27.5;//35.0;
	public static double angleDegreesPerEncoderRev = 60;
//	public static double yValuePerDegree =16;
	

	// private double vBusSet = .25;// per unit
	private double leftTargetSpeed = 600;
	private double rightTargetSpeed = 600;
	private double angleTargetPosition = 0;
	private double angleTargetSpeed = .5;
	

	public static double stopDistance;

	public static boolean getPositionData;
	public static boolean getOrientData;
	public static boolean getLeftShooterData;
	public static boolean getRightShooterData;
	public static boolean getAngleShooterData;
	public static boolean getVisionOrientData;

	public static double orientAngle = 0;
	public static double orientSpeed = .25;

	public static double positionLeftOutput;
	public static double positionRightOutput;

	public static Preferences prefs;

	public static double encoderCountsPerMotorRev = 2048;
	public static double motorMaxRpm = 5600;
	public static double nominalVoltage = 12;

	public static Lidar lidarSensor;
	public static double lidarPulseWidth;

	public static double maxEncoderCountsPerSecond = (motorMaxRpm * encoderCountsPerMotorRev) / 60;

	public static double hiGearMotorToWheelRatio = 7.95;
	public static double loGearMotorToWheelRatio = 16.36;

	public static double driveLeftWheelDiameter = 7.3;
	public static double driveRightWheelDiameter = 7.3;
	public static double wheelDiameterRatio = driveLeftWheelDiameter / driveRightWheelDiameter;

	public static double encoderCountsPerLoGearInch = (encoderCountsPerMotorRev * loGearMotorToWheelRatio)
			/ (driveLeftWheelDiameter * 3.1417);

	public static double encoderCountsPerHiGearInch = (encoderCountsPerMotorRev * hiGearMotorToWheelRatio)
			/ (driveLeftWheelDiameter * 3.1417);

	public static double rotatePosSpeed = .5;
	public static double rotateSlowdownPoint;

	public static boolean isPositioning;
	public static boolean isSamePositioning;
	public static boolean isOrienting;
	public static boolean isVisionOrienting;
	public static boolean isPitchPositioning;
	public static boolean isAutoDriving;

	public static boolean usePID = false;
	public static boolean useSingleJoystick = true;
	public static double gyroOffset;
	public static double gyroReference;
	public static double gyroError;
	public static double leftLinearTarget = 0.0;
	public static double rightLinearTarget = 0.0;
	public static double leftLinearSpeed = .25;
	public static double rightLinearSpeed = .25;

	public static double visionXFwdTarget = -10;
	public static double visionYFwdTarget = -155;
	public static double visionXRevTarget = -10;
	public static double visionYRevTarget = -155;
	public static boolean reverseShoot;
	public static double visionXActiveTarget;
	public static double visionYActiveTarget;

	public static double driveStraightGyroKp = .1;
	public static double squareToGoalKp = .0005;

	public static double initialPitchAngle;
	public static double initialRollAngle;

	public static double airPressurePSI;
	public static AirCompressor airCompressor;
	public static boolean holdCompressor = true;

	public static PowerPanel powerPanel;

	public static AHRS imu;

	Command pidfSet;

	CameraServer server;

	public static Command defenseCommand;
	public static Command slotMoveCommand;
	public static Command goalShootCommand;
	public static Command driveSourceSelect;
	public static Command shooterCommand;
	public static Command gearShift;
	public static double currentMaxSpeed;
	public static boolean inHiGear;

	public static boolean shootHighGoal;
	public static boolean shootLowGoal;
	public static boolean useGoalVision;
	public static boolean useYawComp = false;
	public static boolean useRollComp;
	public static boolean checkCollision;
	public static boolean collisionOccured;
	public static boolean checkStuck;
	public static boolean stuck;
	public static boolean getPitchData;

	public static double pitchRate;

	public static boolean rightMotionCommanded;

	public static boolean leftSideStuck;

	public static boolean rightSideStuck;

	public static boolean leftMotionCommanded;

	public static int leftStuckCounter;
	public static int rightStuckCounter;

	public static int collisionCounter;

	public static boolean motionSeen;

	public static boolean channel0CurrentFault;

	public static boolean channel1CurrentFault;

	public static boolean channel14CurrentFault;

	public static boolean channel15CurrentFault;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	public void robotInit() {

		RobotMap.init();

		speedAngleArray = new double[15];
		speedAngleArray[0] = 5000;// 30 degree
		speedAngleArray[1] = 5000;// 40 degree
		speedAngleArray[2] = 5000;// 50 degree
		speedAngleArray[3] = 5000;// 60 degree
		speedAngleArray[4] = 4000;// 70 degree
		speedAngleArray[5] = 3000;// 80 degree
		speedAngleArray[6] = 3000;// 90 degree
		speedAngleArray[7] = 3000;// 100 degree
		speedAngleArray[8] = 4500;// 110 degree
		speedAngleArray[9] = 5000;// 120 degree
		speedAngleArray[10] = 5000;// 130 degree
		speedAngleArray[11] = 5000;// 140 degree
		speedAngleArray[12] = 5000;// 150 degree
		speedAngleArray[13] = 5000;// 160 degree
		speedAngleArray[14] = 5000;// 170 degree

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		leftSideDrive = new LeftSideDrive();
		rightSideDrive = new RightSideDrive();
		gyroRotate = new GyroRotate();
		rightPositionLinear = new RightPositionLinear();
		leftPositionLinear = new LeftPositionLinear();
		rightShooterMotor = new RightShooterMotor();
		leftShooterMotor = new LeftShooterMotor();
		angleShooterMotor = new AngleShooterMotor();
		airCompressor = new AirCompressor();
		lidarSensor = new Lidar();
		powerPanel = new PowerPanel();
		manipulators = new Manipulators();
		visionRotate = new VisionRotate();
		pitchPosition = new PitchPosition();

		defenseCommand = new CrossMoatGroup();
		slotMoveCommand = new SlotMove1LeftGroup();

		SmartDashboard.putString("DefenseRunning", "None");
		SmartDashboard.putString("Slot Running", "None");
		SmartDashboard.putNumber("Left Wheel Diameter", driveLeftWheelDiameter);
		SmartDashboard.putNumber("Right Wheel Diameter", driveRightWheelDiameter);
		SmartDashboard.putNumber("Lifter Speed", 1.0);

		SmartDashboard.putNumber("Vision Kp", squareToGoalKp);

		table = NetworkTable.getTable("datatable");
		NetworkTable.initialize();
		NetworkTable.flush();

		prefs = Preferences.getInstance();
		(new SetPIDFMotors()).start();
		(new SetPIDFMotorsGyro()).start();
		(new SetPIDFLinearPosition()).start();
		(new DrivesSpeedSourceSelect()).start();
		// (new DrivesSpeedSourceSelectVersion2()).start();
		(new RobotOKCheck()).start();
		// (new FlashlightOff()).start();
		Robot.manipulators.liftOneLower();
		Robot.manipulators.liftTwoLower();
		Robot.manipulators.portcullisChevalManipulatorRaise();
		(new RetractBallSolenoid()).start();
		// RobotMap.shootTrigger.set(true);
		gearShift = (new EngageLowGear());
		gearShift.start();
		RobotMap.angleShooterMotor.setPosition(shooterAngleHomePosition / Robot.angleDegreesPerEncoderRev);

		RobotMap.angleShooterMotor.enableForwardSoftLimit(true);
		 RobotMap.angleShooterMotor.enableReverseSoftLimit(false);
		RobotMap.angleShooterMotor.setForwardSoftLimit(190 / Robot.angleDegreesPerEncoderRev);
//		 RobotMap.angleShooterMotor
//		 .setReverseSoftLimit(10 / Robot.angleDegreesPerEncoderRev);

		// This MUST be here. If the OI creates Commands (which it very likely
		// will), constructing it during the construction of CommandBase (from
		// which commands extend), subsystems are not guaranteed to be
		// yet. Thus, their requires() statements may grab null pointers. Bad
		// news. Don't move it.

		server = CameraServer.getInstance();
		server.setQuality(50);
		// the camera name (ex "cam0") can be found through the roborio web
		// interface
		server.startAutomaticCapture("cam1");

		try {
			imu = new AHRS(SPI.Port.kMXP);
			imu.setPIDSourceType(PIDSourceType.kDisplacement);

		} catch (Exception ex) {
			DriverStation.reportError("Error instantiating navX-MXP:  " + ex.getMessage(), true);
		}
		if (imu != null) {
			LiveWindow.addSensor("IMU", "Gyro", imu);
		}
		imu.setPIDSourceType(PIDSourceType.kDisplacement);
		// instantiate the command used for the autonomous period
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
		// Command autonomousCommand = new AutonomousCommand();

		// SmartDashboard.putNumber("Gyro Target", gyroTarget);

		SmartDashboard.putNumber("Linear Target Inches", 0.0); // leftLinearTarget);
		SmartDashboard.putNumber("Linear Position Speed", leftLinearSpeed);
		SmartDashboard.putNumber("Orient Angle", orientAngle);
		SmartDashboard.putNumber("Orient Speed", orientSpeed);
		SmartDashboard.putNumber("Left Target Speed", leftTargetSpeed);
		SmartDashboard.putNumber("Right Target Speed", rightTargetSpeed);
		SmartDashboard.putNumber("Target Angle", angleTargetPosition);
		SmartDashboard.putNumber("Target Angle Speed", angleTargetSpeed);

		SmartDashboard.putNumber("Intake Speed", -1000);
		SmartDashboard.putNumber("Outtake Speed", -3000);
		SmartDashboard.putNumber("Shoot Speed", 5000);

		// SmartDashboard.putNumber("Vbus Set", vBusSet);

		defenseType = new SendableChooser();
		defenseType.addObject("Portcullis", 1);
		defenseType.addObject("Cheval de Frise", 2);
		defenseType.addObject("Moat", 3);
		defenseType.addObject("Ramparts", 4);
		defenseType.addObject("Drawbridge", 5);
		defenseType.addObject("Sally Port", 6);
		defenseType.addObject("Rock Wall", 7);
		defenseType.addObject("Rough Terrain", 8);
		defenseType.addObject("Low Bar", 9);
		defenseType.addDefault("Do Nothing", 10);

		SmartDashboard.putData("Defense Faced", defenseType);

		defenseSlot = new SendableChooser();

		defenseSlot.addObject("Slot 1 Left Goal", 1);
		defenseSlot.addObject("Slot 2 Left Goal", 2);
		defenseSlot.addObject("Slot 2 Center Goal", 3);
		defenseSlot.addObject("Slot 3 Center Goal", 4);
		defenseSlot.addObject("Slot 4 Center Goal", 5);
		defenseSlot.addObject("Slot 5 Right Goal", 6);
		defenseSlot.addObject("Slot 5 Center Goal", 7);
		defenseSlot.addDefault("Do Nothing", 8);

		SmartDashboard.putData("Defense Slot", defenseSlot);

		goalTarget = new SendableChooser();

		goalTarget.addObject("High Goal", 1);
		goalTarget.addObject("Low Goal", 2);
		goalTarget.addDefault("Do Nothing", 3);

		SmartDashboard.putData("Goal Choice", goalTarget);

		oi = new OI();

		SmartDashboard.putData(Scheduler.getInstance());
		(new ResetGyro()).start();
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	}

	public void autonomousInit() {
		// schedule the autonomous command (example)
		// RobotMap.shootTrigger.set(false);

		Robot.defenseSelected = (int) Robot.defenseType.getSelected();
		SmartDashboard.putNumber("Defense Selected", Robot.defenseSelected);

		switch (Robot.defenseSelected) {

		case 1:
			Robot.defenseCommand = new CrossPortcullisGroup();
			break;
		case 2:
			Robot.defenseCommand = (new CrossChevalDeFriseGroup());
			break;
		case 3:
			Robot.defenseCommand = (new CrossMoatGroup());
			break;
		case 4:
			Robot.defenseCommand = (new CrossRampartsGroup());
			break;
		case 5:
			Robot.defenseCommand = (new CrossDrawbridgeGroup());
			break;
		case 6:
			Robot.defenseCommand = (new CrossSallyPortGroup());
			break;
		case 7:
			Robot.defenseCommand = (new CrossRockWallGroup());
			break;
		case 8:
			Robot.defenseCommand = (new CrossRoughTerrainGroup());
			break;
		case 9:
			Robot.defenseCommand = (new CrossLowBarGroup());
			break;
		case 10:
			Robot.defenseCommand = (new DoNothingGroup());
			break;
		}

		Robot.defenseSlotSelected = (int) Robot.defenseSlot.getSelected();
		SmartDashboard.putNumber("Defense Slot Selected", Robot.defenseSlotSelected);

		switch (Robot.defenseSlotSelected) {
		case 1:
			Robot.slotMoveCommand = (new SlotMove1LeftGroup());
			break;
		case 2:
			Robot.slotMoveCommand = (new SlotMove2LeftGroup());
			break;
		case 3:
			Robot.slotMoveCommand = (new SlotMove2CenterGroup());
			break;
		case 4:
			Robot.slotMoveCommand = (new SlotMove3CenterGroup());
			break;
		case 5:
			Robot.slotMoveCommand = (new SlotMove4CenterGroup());
			break;
		case 6:
			Robot.slotMoveCommand = (new SlotMove5CenterGroup());
			break;
		case 7:
			Robot.slotMoveCommand = (new SlotMove5RightGroup());
			break;
		case 8:
			Robot.slotMoveCommand = (new DoNothingSlotGroup());
			break;
		}

		Robot.goalTargetSelected = (int) Robot.goalTarget.getSelected();
		SmartDashboard.putNumber("Goal Selected", (int) Robot.goalTargetSelected);

		switch (Robot.goalTargetSelected) {

		case 1:
			Robot.shootHighGoal = true;
			Robot.shootLowGoal = false;
			break;
		case 2:
			Robot.shootHighGoal = false;
			Robot.shootLowGoal = true;
			break;
		case 3:
			Robot.shootHighGoal = false;
			Robot.shootLowGoal = false;
			break;
		}

		autonomousCommand = new AutonomousCommand();
		if (autonomousCommand != null) {
			autonomousCommand.start();
		}

	}

	/**
	 * This function is called periodically during autonomous
	 */
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
		updateStatus();

	}

	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.

		// RobotMap.shootTrigger.set(false);
		(new SetPIDFMotors()).start();

		if (autonomousCommand != null) {
			autonomousCommand.cancel();
		}
		if (defenseCommand != null) {
			defenseCommand.cancel();
		}
		if (slotMoveCommand != null) {
			slotMoveCommand.cancel();
		}
		useYawComp = false;
		stuck = false;
		checkStuck = false;
		collisionOccured = false;
		checkCollision = false;
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
		updateStatus();
	}

	public void disabledPeriodic() {
		updateStatus();
	}

	/**
	 * This function called periodically during test mode
	 */
	public void testInit() {
	}

	public void testPeriodic() {
		LiveWindow.run();
		updateStatus();

	}

	public void updateStatus() {
		inAutonomous = isAutonomous();
		SmartDashboard.putBoolean("Shooter Home", RobotMap.shooterHomeSwitch.getTriggerState());

		SmartDashboard.putBoolean("Robot Enabled", isEnabled());
		SmartDashboard.putBoolean("Robot Autonomous", isAutonomous());
		SmartDashboard.putBoolean("Robot Teleop", isOperatorControl());
		SmartDashboard.putBoolean("Single Joystick", useSingleJoystick);
		SmartDashboard.putBoolean("Motors in PID", usePID);
		SmartDashboard.putBoolean("Yaw Comp", useYawComp);
		SmartDashboard.putBoolean("Use Roll Comp", useRollComp);
		SmartDashboard.putBoolean("EYE", !RobotMap.rampEdgeDetect.get());
		SmartDashboard.putBoolean("Not Stuck", !stuck);
		SmartDashboard.putBoolean("Not Collision", !collisionOccured);
		SmartDashboard.putBoolean("Stuck Check", checkStuck);
		SmartDashboard.putBoolean("Collision Check", checkCollision);
		SmartDashboard.putBoolean("LeftStuck", leftSideStuck);
		SmartDashboard.putBoolean("Right Stuck", rightSideStuck);
		SmartDashboard.putNumber("Left Stuck Count", leftStuckCounter);
		SmartDashboard.putNumber("Right Stuck Count", rightStuckCounter);
		SmartDashboard.putNumber("Collision Count", collisionCounter);

		Robot.leftSideDrive.updateStatus();
		Robot.rightSideDrive.updateStatus();
		Robot.gyroRotate.updateStatus();
		Robot.leftPositionLinear.updateStatus();
		Robot.rightPositionLinear.updateStatus();
		Robot.rightShooterMotor.updateStatus();
		Robot.leftShooterMotor.updateStatus();
		Robot.angleShooterMotor.updateStatus();
		Robot.lidarSensor.updateStatus();
		Robot.airCompressor.updateStatus();
		Robot.powerPanel.updateStatus();
		Robot.manipulators.updateStatus();
		Robot.visionRotate.updateStatus();
		Robot.pitchPosition.updateStatus();

		if (getPositionData) {
			(new RobotPosition(SmartDashboard.getNumber("Linear Target Inches"),
					SmartDashboard.getNumber("Linear Position Speed"), .5, true, 10)).start();// last
																								// 3
																								// params
																								// are
																								// in
																								// position
																								// band
																								// Inches,
			// disable when done and timeout seconds
			getPositionData = false;
		}
		if (getOrientData) {
			(new RobotOrient(SmartDashboard.getNumber("Orient Angle"), SmartDashboard.getNumber("Orient Speed"), 10))
					.start();
			getOrientData = false;
		}
		if (getLeftShooterData) {
			(new RunLeftShooter(SmartDashboard.getNumber("Left Target Speed"))).start();
			getLeftShooterData = false;
		}
		if (getRightShooterData) {
			(new RunRightShooter(SmartDashboard.getNumber("Right Target Speed"))).start();
			getRightShooterData = false;
		}
		if (getAngleShooterData) {
			(new PositionAngleShooter(SmartDashboard.getNumber("Target Angle"),
					SmartDashboard.getNumber("Target Angle Speed"), 10)).start();
			getAngleShooterData = false;
		}
		if (getVisionOrientData) {
			(new RobotVisionOrient(-10, SmartDashboard.getNumber("Orient Speed"))).start();
			getVisionOrientData = false;
		}
		if (getPitchData) {
			(new RobotPitchPosition(SmartDashboard.getNumber("Orient Angle"), SmartDashboard.getNumber("Orient Speed"),
					15)).start();
			getPitchData = false;
		}

		// NetworkTable computer vision data
		// table.
		xCameraVal = table.getNumber("XCameraValue", 1000);
		yCameraVal = table.getNumber("YCameraValue", 1000);
		NetworkTable.flush();
		squareToGoalKp = SmartDashboard.getNumber("Vision Kp");
	}
}
